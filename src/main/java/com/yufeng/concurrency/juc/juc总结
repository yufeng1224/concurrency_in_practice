------------------------------------------------------------------------------------------------------------------------
threadPool(线程池)

① 讲一讲线程池?
   1. 线程池是一种用于管理维护多个线程的资源池工具, 它产生的原因是因为线程的频繁创建和销毁操作会带来巨大的开销, 因此需要使用常驻的线程
   2. 那么线程池能够做到这个功能, 它通过复用池中的线程, 可以去合理利用CPU和内存资源, 提高系统的响应速度

   3. 在Java中, 线程池的核心类是ThreadPoolExecutor, 它是在jdk1.5的时候, 随着Executor并发框架体系一起引入的
      3-1 那么Executor并发框架引入的目的就是为了让任务的提交和执行过程进行解耦
      3-2 它主要是由3部分组成, 分别是: 任务接口模块、任务执行接口以及异步计算结果返回模块
      3-3 ThreadPoolExecutor它继承的AbstractExecutorService抽象类, 并且实现了顶层接口Executor接口, 因此它是属于任务执行模块的内容
      3-4 在其它方面, 任务模块主要是由Runnable和Callable 2个核心接口组成;  异步计算结果返回则主要是由Future接口和FutureTask实现类组成

   4. 接着回到线程池, 讲一下它的核心参数, 总共有6个, 分别是
      4-1 corePoolSize: 核心线程数
      4-2 maximumPoolSize: 最大线程数
      4-3 keepAliveTime: 非核心线程的空闲时间
      4-4 workQueue: 任务队列
      4-5 threadFactory: 线程工厂
      4-6 以及 RejectedExecutionHandler: 拒绝策略处理器

   5. 那么根据传入参数的不同, 可以创建不同类型的线程池。 比如Java中的Executors工具类就提供了5种类型的线程池
      5-1 第一种是固定线程池(FixedThreadPool), 它的特点就是线程数固定, 使用的是无界队列,
          它适用于任务数量不均匀的场景、对内存压力不敏感但系统负载比较敏感的场景
      5-2 第二种是缓存线程池(CachedThreadPool), 它的特点是不限制线程数, 因此适用于要求低延迟的短期任务场景
      5-3 第三种是单线程池(SingleThreadExecutor), 它是只有一个线程的固定线程池, 适用于需要异步执行但要保证任务顺序的场景
      5-4 第四种是定时任务线程池(ScheduledThreadPool), 它适用于定期执行任务的场景, 支持按固定频率定期执行和按固定延时定期执行两种方式
      5-5 最后一种是工作窃取线程池(ForkJoinPool), 它适合任务执行时长不均匀的场景

      5-6 todo 那么在实际的开发中, 我通常都是通过具体的业务场景自定义线程池, 这样也可以防止OOM
               比如实际应用场景中...
               (另外注意慎用无界队列，可能会有 OOM 的风险)

   6. 接着讲一下线程池创建之后的执行规则, 规则有4条
      6-1 第一条是如果线程数小于核心线程数, 则即使其他线程处于空闲状态, 线程池也会创建一个新的线程来执行任务
      6-2 第二条是如果线程数已经等于核心线程数, 但是少于最大线程数, 则会将任务放入到队列中
      6-3 第三条是如果队列也已经满了, 但是线程数小于最大线程数, 这样会创建一个新线程来执行任务
      6-4 第四条是如果队列满了, 并且线程数也满了, 则会去执行拒绝策略

   7. todo: 线程池复用的原理等知识点还未总结。原因是原子类和阻塞队列还不太熟悉


② 线程池的状态有5种, 分别是:
   1. RUNNING: 接受新任务并处理排队任务
   2. SHUTDOWN: 不接受新任务, 但处理排队任务
   3. STOP: 不接受新任务, 也不处理排队任务, 并中断正在进行的任务
   4. TIDYING: 所有任务都已终止, workerCount为零时, 线程池会变为TIDYING状态, 并将运行terminate()钩子方法
   5. TERMINATED: 线程池运行终止


③ 讲一讲Callable和Runnable接口?
   1. Callable和Runnable接口都属于Executor并发框架体系中的任务模块, 并且它们都能够将任务提交到线程池中运行
   2. Callable和Runnable的区别
      2-1 Callable的任务执行后是有返回值的, 而Runnable的任务是没有返回值的
      2-2 Callable接口中的call()方法可以抛出异常, 而Runnable接口中的run()方法是不能抛出异常的


③ 讲一讲Future接口?
   1. Future接口的作用是接收异步任务计算的结果, 并且它还可以检查任务是否已完成或者取消任务的执行
   2. 接口中有5个方法, 分别是: cancel()、 isCancelled()、 isDone()、 get()以及带有时间参数的get()方法
   3. cancel()方法的作用是取消任务的执行, 它会返回布尔值。
      3-1 如果任务还未执行, 则直接返回true
      3-2 如果任务已经执行完成或者已经被取消, 则返回false
      3-3 如果任务已经在运行中, 则还需要通过传入的true或者false来确定是否中断任务, 最终返回true

   4. isCancelled()方法的作用是判断任务是否已经被取消了
   5. isDone()方法的作用是判断任务是否已经运行结束
   6. get()方法的作用是获取异步任务计算的结果。这里会细分为3种情况:
      6-1 如果计算还没有结束, 则当前线程会处于阻塞状态, 直到执行结束获取结果
      6-2 如果执行过程中遇到异常, 则会统一抛出ExecutionException
      6-3 如果任务被取消, 则会抛出CancellationException

   7 带有时间参数的get()方法的作用是在指定时间内获取计算的结果, 否则会抛出TimeoutException, 其它功能与get()方法类似
   8 Future的注意点
     8-1 使用Future需要注意的是, 当for循环批量获取future的结果时, 可能会发生一部分线程很慢的情况, 比如future0的结果还没有计算完成,
         而future1和future2的结果已经计算完毕, 此时却只能陷入阻塞中
         那么解决方案就是使用CompletionService, 它会将计算完成的结果存入到队列中
     8-2 其他的注意点是: Future的生命周期不能后退的


------------------------------------------------------------------------------------------------------------------------
并发容器模块

① 讲一讲 CopyOnWriteArrayList
   1. CopyOnWriteArrayList 是一个线程安全的, 并且是读写分离的动态数组类
   2. 在这个类的内部, 它维护了一个array数组变量, 并使用volatile关键字来保证可见性
      2-1 那么当它在进行增删改操作时, 会通过 ReentrantLock 来进行加锁, 然后将原数组的内容复制一份, 接着对新数组进行操作,
          最后将array变量指向新的数组, 这也是它 CopyOnWrite 的含义
      2-2 最后还有一个读取操作是无锁进行的

   3. 另外还需要注意的是, CopyOnWriteArrayList 只有写写是互斥的, 需要同步等待。而其它操作是不互斥的, 因此性能会得到很大的提升。
      所以它非常适合读多写少的场景: 比如 白名单、黑名单机制, 商品类目的每日更新
   4. 不过它也有缺陷: 比如无法保证数据的实时一致性, 还有就是复制数组时的内存占用问题
   todo 以后项目中应用到白名单这种场景时, 观察一下它的底层实现是否是 CopyOnWriteArrayList


知识点延伸扩展 ———— 讲一讲 ArrayList
   1. ArrayList 是基于数组实现的一个动态数组, 它是非线程安全的
   2  它每次添加元素时, 都会对容量进行检查, 扩容时则会增长为原来容量的1.5倍, 它适合查询、修改频繁的场景
   3. 使用 ArrayList 需要注意的是,  在迭代时它不能使用list进行增删操作, 否则会抛出 ConcurrentModificationException
      解决方案是可以使用 iterator 进行删除操作


② 讲一讲阻塞队列 BlockingQueue
   1. BlockingQueue 是一个具有阻塞功能的队列接口, 它是线程安全的。 在并发环境下, 通过一个共享的阻塞队列, 可以高效安全的传输数据
   2. 那么它的阻塞功能是通过 put() 和 take() 函数来实现的
      2-1 当调用 put() 函数插入元素时, 如果队列已经满了, 则它会挂起插入元素的线程, 直到队列不满
      2-2 而当调用 take()函数取出元素时, 如果队列已经空了, 则它会挂起取出元素的线程, 直到队列中又有了数据
      2-3 另外, 在函数内部, 它使用到了 ReentrantLock 来确保线程安全, 并且利用了Lock锁的Condition通知机制进行阻塞控制

   3. 接着讲一下 BlockingQueue 的常用实现类, 有 ArrayBlockingQueue、 LinkedBlockingQueue、 PriorityBlockingQueue、
      SynchronousQueue、 DelayQueue等

   4. ArrayBlockingQueue




------------------------------------------------------------------------------------------------------------------------
AQS同步组件(也称为AQS同步器) ———— 并发流程控制模块

① 讲一讲 Condition
   1. Condition 是一个接口, 它的实现类是ConditionObject, 底层是基于AQS实现的。 那么在接口中, 有await()和signal()两个核心函数,
      它们与Object类中的wait()和notify()函数功能类似。 因此 Condition 也能够协调线程之间的通信

   2. 不过相比于wait/notify组合, condition是依赖于Lock对象的, 并且可以创建多个条件, 因此使用更为灵活。然后在性能方面condition也会更好
   3. 在应用方面, condition 在生产者/消费者模式中使用较多, 比如消息队列。 在Java中, BlockingQueue的具体实现类中就大量使用到了condition



------------------------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------